name: Deploy URL Shortener

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write         # REQUIRED for GitHub OIDC -> AWS
  contents: read          # allows checkout

env:
  AWS_REGION: us-east-1                         # keep consistent with your setup
  ARTIFACT_BUCKET: ddemo-artifacts-676206911400-us-east-1  #Will later want account id to be a secret.  Probably good to add for security section
  ARTIFACT_KEY: releases/current.zip

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install app + dev deps
        run: |
          python -m pip install --upgrade pip
          pip install -r app/requirements.txt
          pip install -r requirements-dev.txt

      - name: Lint (flake8)
        run: |
          flake8 .

      - name: Run tests (pytest)
        run: |
          pytest -q

  build-and-deploy:
    needs: [lint-and-test] #Adding lint/test dependency
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Write build info (UTC timestamp + commit)
        run: |
          ts_utc=$(date -u +"%Y-%m-%dT%H:%M:%SZ")   # ISO-8601 UTC
          sha="${GITHUB_SHA:-local}"
          mkdir -p app
          cat > app/.buildinfo.json <<EOF
          {
            "deployed_at_utc": "${ts_utc}",
            "git_sha": "${sha}"
          }
          EOF

      # Package the app
      - name: Zip /app folder as release artifact
        run: |
          mkdir -p build
          (cd app && zip -r ../build/app.zip .)
          ls -lh build

      # Configure AWS credentials via OIDC (no long-lived keys)
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::676206911400:role/GitHubActionsDeployRole  # <-- replace ACCOUNT_ID and role name if different
          aws-region: ${{ env.AWS_REGION }}

      # Upload the artifact to S3
      - name: Upload artifact to S3
        run: |
          aws s3 cp build/app.zip "s3://${ARTIFACT_BUCKET}/${ARTIFACT_KEY}" --acl private
      
      # Terraform to provision/update infra in ./infra
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init/Plan/Apply
        working-directory: infra
        run: |
          terraform init -input=false
          terraform plan -input=false \
            -var="region=${{ env.AWS_REGION }}" \
            -var="artifact_bucket=${{ env.ARTIFACT_BUCKET }}" \
            -var="artifact_key=${{ env.ARTIFACT_KEY }}"
          terraform apply -auto-approve -input=false \
            -var="region=${{ env.AWS_REGION }}" \
            -var="artifact_bucket=${{ env.ARTIFACT_BUCKET }}" \
            -var="artifact_key=${{ env.ARTIFACT_KEY }}"

      - name: Capture Terraform outputs (fresh IDs)
        id: tf_out
        working-directory: infra
        run: |
            echo "INSTANCE_ID=$(terraform output -raw instance_id)" >> "$GITHUB_OUTPUT"
            echo "PUBLIC_DNS=$(terraform output -raw public_dns)"   >> "$GITHUB_OUTPUT"
        
      - name: Wait for EC2 to be running
        run: |
            aws ec2 wait instance-running --instance-ids "${{ steps.tf_out.outputs.INSTANCE_ID }}"
    
      - name: Wait for EC2 status checks to pass
        run: |
            aws ec2 wait instance-status-ok --instance-ids "${{ steps.tf_out.outputs.INSTANCE_ID }}"

      # Read instance ID & public DNS from Terraform outputs
      - name: Read Terraform outputs
        id: tf
        working-directory: infra
        run: |
          echo "INSTANCE_ID=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
          echo "PUBLIC_DNS=$(terraform output -raw public_dns)" >> $GITHUB_OUTPUT

      # Trigger deploy script on the instance via SSM Run Command
      - name: Trigger deploy via SSM
        run: |
          aws ssm send-command \
            --instance-ids "${{ steps.tf.outputs.INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "DDemo deploy" \
            --parameters commands=["/usr/local/bin/deploy.sh s3://${{ env.ARTIFACT_BUCKET }}/${{ env.ARTIFACT_KEY }} && sudo systemctl restart urlshort.service"] \
            --output text

      # (Optional but nice) Wait for app to be healthy
      - name: Wait for /healthz
        run: |
          set -e
          URL="http://${{ steps.tf.outputs.PUBLIC_DNS }}/healthz"
          echo "Waiting for $URL ..."
          for i in {1..30}; do
            if curl -sSf "$URL" > /dev/null; then
              echo "OK!"
              exit 0
            fi
            echo "not ready yet... ($i)"
            sleep 5
          done
          echo "App did not become healthy in time."
          exit 1

      - name: Echo site URL
        run: echo "Site == http://${{ steps.tf.outputs.PUBLIC_DNS }}"